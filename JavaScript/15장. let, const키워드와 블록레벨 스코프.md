# 15. let, const키워드와 블록레벨 스코프

## 15.1 var 키워드로 선언한 변수의 분제점

ES5까지는 변수를 선언할 수 있는 유일한 방법은 var 뿐이었다.

하지만 var에는 독특한 특징이 있어 주의하지 않으면 심각한 오류를 발생한다.

### 15.1.1 변수 중복 선언 허용

var는 변수를 중복해서 선언하면 기존에 있던 값이 사라진다.

```jsx
var x = 1;
var y = 1;

var x = 100;

console.log(x); // 100
console.log(y); // 1
```

### 15.1.2 함수 레벨 스코프

var는 함수의 코드블록만을 지역 스코프로 인정한다.

즉, if문과 for문에서의 var는 전역변수로 선언된다.

### 15.1.3 함수 호이스팅

함수 호이스팅에 의해 변수의 선언의 스코프의 선두로 끌어올려 진다.

단, 할당은 별개이므로 변수에 값을 할당전에 참조한다면 undefined가 뜬다.

```jsx
// 이 단계에서 foo 변수는 이미 선언
// foo에 값 할당은 안되어있기 때문에, undefined로 초기화
console.log(foo); // undefined

foo = 123; // foo에 123 할당

console.log(foo); // 123

var foo; // 변수 선언은 런타임 이전에 js 엔진이 실행
// 즉 변수 선언 전에 변수를 참조하는 건, 오류는 안뜨지만 가독성과 오류의 여지를 남긴다.
```

## 15.2 let 키워드

ES6에서 나온 var 단점을 보완하는 새로운 변수 선원 키워드

### 15.2.1 변수 중복 선언 금지

var와 다르게 let은 변수를 중복선언 하면 SyntexError가 뜬다.

### 15.2.2 블록 레벨 스코프

함수 레벨 스코프인 var와 다르게 let은 모든 코드 블록을 지역 스코프로 인정한다.

즉, let은 블록 레벨 스코프이다.

```jsx
let foo = 1;

{
  let foo = 2;
  let bar = 3;
  console.log(foo); // 2
}

console.log(foo); // 1
console.log(bar); // Error
```

### 15.2.3 변수 호이스팅

let은 var와 다르게 변수 호이스팅이 발생하지 않는 것처럼 동작한다.

var는 선언할 때, 값의 초기화까지 진행된다.

하지만 let은 선언 단계와 초기화 단계가 분리되어 진행된다.

그래서 let 변수는 스코프 시작 지점부터 초기화 단계 시작 지점까지 변수를 참조할 수 없는데,

이 구간을 **일시적 사각지대*temporal dead zon***이라고 부른다.

```jsx
// foo가 선언되었지만 초기화되진 않았다. 일시적 사각지대의 상태
console.log(foo); // ReferenceError

let foo; // 변수 선언문 단게에서 초기화가 이루어진다
console.log(foo); // undefined

foo = 1; // 값을 할당
console.log(foo); // 1
```

### 15.2.4 전역 객체와 let

var는 전역 객체 window의 프로퍼티가 된다. window는 생략 가능하다.

하지만 let은 전역 객체 window의 프로퍼티가 아니다.

let의 전역 변수는 보이지 않는 개념적인 블록 내에 존재한다.

## 15.3 const 키워드

const는 상수를 선언하기 위해 사용한다.

하지만 반드시 상수만을 위해 쓰진 않는다.

### 15.3.1 선언과 초기화

const는 반드시 선언과 동시에 초기화를 해야한다.

```jsx
const foo = 1;
```

const는 let과 동일하게 블록 레벨 스코프이며, 호이스팅이 발생하지 않는 것처럼 동작한다.

### 15.3.2 재할당 금지

const로 선언한 변수는 재할당이 금지된다.

```jsx
const foo = 1;
foo = 2; // TypeError
```

### 15.3.3 상수

상수는 상태 유지와 가독성, 유지보수의 편의를 위해 적극적으로 사용해야 한다.

일반적으로 상수 이름은 대문자로 선언하고, 스네이크 케이스로 표현한다.

const로 선언된 변수에 원시 값을 할당한 경우, 원시 값은 변경할 수 없는 값이고 const 키워드에 의해 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없다.

### 15.3.4 const 키워드와 객체

const로 선언된 변수에 원시 값을 할당하면 값을 바꿀 수 없다.

하지만 const로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있다.

```jsx
const person = {
  name: "Lee",
};

person.name = "Kim";

console.log(person); // {name: "Kim"}
```

## 15.4 var vs let vs const

ES6 기준 var는 쓰지 않는다.

생각보다 재할당 되는 경우가 없다. 기본적으로 const를 활용한다.

재할당이 정말로 필요하다면 let을 쓴다. 이때 변수의 스코프는 최대한 좁게한다.
